<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Machine</title>
    <style>
        body { 
            text-align: center; 
            font-family: Arial, sans-serif; 
            background-color: white; 
            color: black; 
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            height: 100vh;
            justify-content: center;
        }
        .container {
            display: flex;
            gap: 20px;
            margin: 20px;
        }
        .canvas-wrapper {
            position: relative;
        }
        canvas { 
            border: 1px solid black; 
            background-color: white; 
        }
        #fractalCanvas {
            width: 800px;
            height: 800px;
        }
        #editorCanvas {
            width: 300px;
            height: 300px;
        }
        .controls { 
            margin-top: 10px; 
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-width: 800px;
        }
        .editor-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        label {
            margin: 0 10px;
        }
        #zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .zoom-button {
            font-size: 24px;
            padding: 5px 10px;
            margin: 5px;
            cursor: pointer;
            background-color: #f1f1f1;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <h1>Fractal Machine</h1>
    <div id="zoom-controls">
        <button class="zoom-button" onclick="zoomIn()">+</button>
        <button class="zoom-button" onclick="zoomOut()">-</button>
    </div>
    <div class="container">
        <div class="canvas-wrapper">
            <canvas id="fractalCanvas" width="800" height="800"></canvas>
        </div>
        <div class="editor-controls">
            <h3>Polygon Editor</h3>
            <canvas id="editorCanvas" width="300" height="300"></canvas>
            <button onclick="addPoint()">Add Point</button>
            <button onclick="clearPoints()">Clear Points</button>
            <button onclick="applyCustomPolygon()">Apply Polygon</button>
        </div>
    </div>
    <div class="controls">
        <label>Animation Speed: <input type="range" id="animationSpeed" min="0.1" max="5" value="1" step="0.1"></label>
        <label>Iterations: <input type="number" id="iterations" value="5" min="1" max="10"></label>
        <label>Scale X: <input type="number" id="scaleX" value="1" step="0.1"></label>
        <label>Scale Y: <input type="number" id="scaleY" value="1" step="0.1"></label>
        <label>Rotation: <input type="number" id="rotation" value="30"></label>
        <label>Shear X: <input type="number" id="shearX" value="0" step="0.1"></label>
        <label>Shear Y: <input type="number" id="shearY" value="0" step="0.1"></label>
        <label>Offset X: <input type="number" id="offsetX" value="0"></label>
        <label>Offset Y: <input type="number" id="offsetY" value="0"></label>
        <button onclick="toggleInvertColors()">Invert Colors</button>
        <button onclick="startAnimation()">Start Animation</button>
        <button onclick="stopAnimation()">Stop Animation</button>
        <button onclick="setPolygon(3)">Triangle</button>
        <button onclick="setPolygon(4)">Square</button>
        <button onclick="setPolygon(5)">Pentagon</button>
        <button onclick="resetFractal()">Reset</button>
    </div>
<script>
        const canvas = document.getElementById("fractalCanvas");
        const ctx = canvas.getContext("2d");
        const editorCanvas = document.getElementById("editorCanvas");
        const editorCtx = editorCanvas.getContext("2d");
        
        let frame = 0;
        let invertColors = false;
        let animationFrame;
        let polygonSides = 3;
        let lastTimestamp = 0;
        let defaultValues = {
            animationSpeed: 1,
            iterations: 5,
            scaleX: 1,
            scaleY: 1,
            rotation: 30,
            shearX: 0,
            shearY: 0,
            offsetX: 0,
            offsetY: 0
        };

        let zoomLevel = 1;
        
        // Polygon editor variables
        let points = [];
        let isDragging = false;
        let dragIndex = -1;
        let customPolygonPoints = null;

        function initializeEditor() {
            editorCanvas.addEventListener('mousedown', startDragging);
            editorCanvas.addEventListener('mousemove', drag);
            editorCanvas.addEventListener('mouseup', stopDragging);
            drawEditor();
        }

        function startDragging(e) {
            const rect = editorCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (editorCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (editorCanvas.height / rect.height);

            for (let i = 0; i < points.length; i++) {
                const dx = points[i].x - x;
                const dy = points[i].y - y;
                if (dx * dx + dy * dy < 100) {
                    isDragging = true;
                    dragIndex = i;
                    return;
                }
            }
        }

        function drag(e) {
            if (!isDragging) return;
            
            const rect = editorCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (editorCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (editorCanvas.height / rect.height);
            
            points[dragIndex] = { x, y };
            drawEditor();
        }

        function stopDragging() {
            isDragging = false;
            dragIndex = -1;
        }

        function addPoint() {
            const centerX = editorCanvas.width / 2;
            const centerY = editorCanvas.height / 2;
            points.push({ x: centerX, y: centerY });
            drawEditor();
        }

        function clearPoints() {
            points = [];
            drawEditor();
        }

        function drawEditor() {
            editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
            editorCtx.strokeStyle = invertColors ? "white" : "black";
            
            // Draw grid
            editorCtx.beginPath();
            editorCtx.strokeStyle = "#ddd";
            for (let i = 0; i <= editorCanvas.width; i += 50) {
                editorCtx.moveTo(i, 0);
                editorCtx.lineTo(i, editorCanvas.height);
                editorCtx.moveTo(0, i);
                editorCtx.lineTo(editorCanvas.width, i);
            }
            editorCtx.stroke();

            // Draw center crosshair
            const centerX = editorCanvas.width / 2;
            const centerY = editorCanvas.height / 2;
            editorCtx.beginPath();
            editorCtx.strokeStyle = "#f00";
            editorCtx.moveTo(centerX - 10, centerY);
            editorCtx.lineTo(centerX + 10, centerY);
            editorCtx.moveTo(centerX, centerY - 10);
            editorCtx.lineTo(centerX, centerY + 10);
            editorCtx.stroke();

            // Draw polygon
            if (points.length > 1) {
                editorCtx.beginPath();
                editorCtx.strokeStyle = invertColors ? "white" : "black";
                editorCtx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    editorCtx.lineTo(points[i].x, points[i].y);
                }
                editorCtx.closePath();
                editorCtx.stroke();
            }

            // Draw points
            points.forEach(point => {
                editorCtx.beginPath();
                editorCtx.fillStyle = invertColors ? "white" : "black";
                editorCtx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                editorCtx.fill();
            });
        }

        function applyCustomPolygon() {
            if (points.length >= 3) {
                // Calculate centroid
                let sumX = 0, sumY = 0;
                points.forEach(point => {
                    sumX += point.x;
                    sumY += point.y;
                });
                const centroidX = sumX / points.length;
                const centroidY = sumY / points.length;

                // Center the points relative to centroid
                customPolygonPoints = points.map(point => ({
                    x: point.x - centroidX,
                    y: point.y - centroidY
                }));
                points = [];
                drawEditor();
                renderFractal();
            }
        }

        function setPolygon(sides) {
            polygonSides = sides;
            renderFractal();
        }

        function applyTransformation() {
            const scaleX = parseFloat(document.getElementById("scaleX").value);
            const scaleY = parseFloat(document.getElementById("scaleY").value);
            const rotation = parseFloat(document.getElementById("rotation").value);
            const shearX = parseFloat(document.getElementById("shearX").value);
            const shearY = parseFloat(document.getElementById("shearY").value);
            const offsetX = parseFloat(document.getElementById("offsetX").value);
            const offsetY = parseFloat(document.getElementById("offsetY").value);
            
            const transform = new DOMMatrix();
            transform.scale(scaleX, scaleY);
            transform.rotate(rotation);
            transform.shear(shearX, shearY);
            transform.translate(offsetX, offsetY);
            return transform;
        }

        function zoomIn() {
            zoomLevel += 0.1;
            renderFractal();
        }

        function zoomOut() {
            zoomLevel = Math.max(zoomLevel - 0.1, 0.1);
            renderFractal();
        }

        function renderFractal() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            const transform = applyTransformation();
            ctx.setTransform(transform);
            ctx.scale(zoomLevel, zoomLevel);

            const iterations = parseInt(document.getElementById("iterations").value);
            drawFractal(iterations, canvas.width / 2, canvas.height / 2);
            ctx.restore();
        }

        function drawFractal(iterations, x, y) {
            if (iterations === 0) return;

            if (customPolygonPoints) {
                const angleStep = Math.PI * 2 / polygonSides;
                for (let i = 0; i < polygonSides; i++) {
                    const xOffset = Math.cos(i * angleStep) * 50;
                    const yOffset = Math.sin(i * angleStep) * 50;
                    ctx.beginPath();
                    ctx.moveTo(x + xOffset, y + yOffset);
                    ctx.lineTo(x + customPolygonPoints[i % customPolygonPoints.length].x, y + customPolygonPoints[i % customPolygonPoints.length].y);
                    ctx.stroke();
                }
            }
        }

        // Initialize the fractal and editor
        function startAnimation() {
            lastTimestamp = performance.now();
            requestAnimationFrame(animate);
        }

        function stopAnimation() {
            cancelAnimationFrame(animationFrame);
        }

        function animate(timestamp) {
            const delta = (timestamp - lastTimestamp) * parseFloat(document.getElementById("animationSpeed").value);
            lastTimestamp = timestamp;
            renderFractal();
            animationFrame = requestAnimationFrame(animate);
        }

        function resetFractal() {
            points = [];
            customPolygonPoints = null;
            renderFractal();
        }

        // Initialize everything
        initializeEditor();
        renderFractal();
</script>
</body>
</html>
