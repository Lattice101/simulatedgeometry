<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Machine</title>
    <style>
        body { 
            text-align: center; 
            font-family: Arial, sans-serif; 
            background-color: white; 
            color: black; 
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            display: flex;
            gap: 20px;
            margin: 20px;
        }
        .canvas-wrapper {
            position: relative;
        }
        canvas { 
            border: 1px solid black; 
            background-color: white; 
        }
        #fractalCanvas {
            width: 800px;
            height: 800px;
        }
        #editorCanvas {
            width: 300px;
            height: 300px;
        }
        .controls { 
            margin-top: 10px; 
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-width: 800px;
        }
        .editor-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        .attachment-points {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
            margin: 10px;
        }
        label {
            margin: 0 10px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>
    <h1>Fractal Machine</h1>
    <div class="container">
        <div class="canvas-wrapper">
            <canvas id="fractalCanvas" width="800" height="800"></canvas>
        </div>
        <div class="editor-controls">
            <h3>Step Editor</h3>
            <canvas id="editorCanvas" width="300" height="300"></canvas>
            <div>
                <label>Base Line Length: <input type="number" id="baseLength" value="100" min="10" max="300"></label>
            </div>
            <div class="attachment-points" id="attachmentPoints">
                <!-- Populated dynamically -->
            </div>
            <button onclick="addPoint()">Add Point</button>
            <button onclick="clearPoints()">Clear Points</button>
            <button onclick="applyStep()">Apply Step</button>
        </div>
    </div>
    <div class="controls">
        <label>Animation Speed: <input type="range" id="animationSpeed" min="0.1" max="5" value="1" step="0.1"></label>
        <label>Steps: <input type="number" id="steps" value="1" min="1" max="10"></label>
        <label>Iterations: <input type="number" id="iterations" value="5" min="1" max="10"></label>
        <label>Scale: <input type="number" id="scale" value="1" step="0.1"></label>
        <label>Rotation: <input type="number" id="rotation" value="30"></label>
        <button onclick="toggleInvertColors()">Invert Colors</button>
        <button onclick="startAnimation()">Start Animation</button>
        <button onclick="stopAnimation()">Stop Animation</button>
        <button onclick="resetFractal()">Reset</button>
    </div>
<script>
        const canvas = document.getElementById("fractalCanvas");
        const ctx = canvas.getContext("2d");
        const editorCanvas = document.getElementById("editorCanvas");
        const editorCtx = editorCanvas.getContext("2d");
        
        let frame = 0;
        let invertColors = false;
        let animationFrame;
        let lastTimestamp = 0;
        let points = [];
        let isDragging = false;
        let dragIndex = -1;
        let stepPoints = [];
        let attachmentPoints = [];

        const defaultValues = {
            animationSpeed: 1,
            steps: 1,
            iterations: 5,
            scale: 1,
            rotation: 30,
            baseLength: 100
        };

        function initializeEditor() {
            editorCanvas.addEventListener('mousedown', startDragging);
            editorCanvas.addEventListener('mousemove', drag);
            editorCanvas.addEventListener('mouseup', stopDragging);
            updateAttachmentPointsUI();
            drawEditor();
        }

        function updateAttachmentPointsUI() {
            const container = document.getElementById('attachmentPoints');
            container.innerHTML = '';
            
            // Add vertex checkboxes
            for (let i = 0; i < points.length; i++) {
                const label = document.createElement('label');
                label.className = 'checkbox-label';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `vertex-${i}`;
                checkbox.checked = attachmentPoints.includes(`vertex-${i}`);
                checkbox.onchange = () => updateAttachmentPoints(checkbox.id);
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(`Vertex ${i + 1}`));
                container.appendChild(label);
            }
        }

        function updateAttachmentPoints(id) {
            const index = attachmentPoints.indexOf(id);
            if (index === -1) {
                attachmentPoints.push(id);
            } else {
                attachmentPoints.splice(index, 1);
            }
            drawEditor();
        }

        function startDragging(e) {
            const rect = editorCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (editorCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (editorCanvas.height / rect.height);

            for (let i = 0; i < points.length; i++) {
                const dx = points[i].x - x;
                const dy = points[i].y - y;
                if (dx * dx + dy * dy < 100) {
                    isDragging = true;
                    dragIndex = i;
                    return;
                }
            }
        }

        function drag(e) {
            if (!isDragging) return;
            
            const rect = editorCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (editorCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (editorCanvas.height / rect.height);
            
            points[dragIndex] = { x, y };
            drawEditor();
        }

        function stopDragging() {
            isDragging = false;
            dragIndex = -1;
        }

        function addPoint() {
            const centerX = editorCanvas.width / 2;
            const centerY = editorCanvas.height / 2;
            points.push({ x: centerX, y: centerY });
            updateAttachmentPointsUI();
            drawEditor();
        }

        function clearPoints() {
            points = [];
            attachmentPoints = [];
            updateAttachmentPointsUI();
            drawEditor();
        }

        function drawEditor() {
            editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
            editorCtx.strokeStyle = invertColors ? "white" : "black";
            
            // Draw grid
            editorCtx.beginPath();
            editorCtx.strokeStyle = "#ddd";
            for (let i = 0; i <= editorCanvas.width; i += 50) {
                editorCtx.moveTo(i, 0);
                editorCtx.lineTo(i, editorCanvas.height);
                editorCtx.moveTo(0, i);
                editorCtx.lineTo(editorCanvas.width, i);
            }
            editorCtx.stroke();

            // Draw base line
            const baseLength = parseInt(document.getElementById("baseLength").value);
            const startX = editorCanvas.width / 2 - baseLength / 2;
            const startY = editorCanvas.height / 2;
            editorCtx.beginPath();
            editorCtx.strokeStyle = "#666";
            editorCtx.moveTo(startX, startY);
            editorCtx.lineTo(startX + baseLength, startY);
            editorCtx.stroke();

            // Draw points and connections
            if (points.length > 0) {
                editorCtx.beginPath();
                editorCtx.strokeStyle = invertColors ? "white" : "black";
                editorCtx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    editorCtx.lineTo(points[i].x, points[i].y);
                }
                if (points.length > 2) {
                    editorCtx.closePath();
                }
                editorCtx.stroke();
            }

            // Draw points
            points.forEach((point, i) => {
                editorCtx.beginPath();
                editorCtx.fillStyle = attachmentPoints.includes(`vertex-${i}`) ? "red" : (invertColors ? "white" : "black");
                editorCtx.arc(point.x, point.y, 5, 0, Math.PI * 2);
                editorCtx.fill();
            });
        }

        function applyStep() {
            if (points.length >= 2) {
                stepPoints = [...points];
                resetFractal();
            } else {
                alert("Please add at least 2 points to create a step");
            }
        }

        function drawFractalStep(x, y, size, angle, baseLength) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle * Math.PI / 180);
            
            // Draw base line
            ctx.beginPath();
            ctx.moveTo(-baseLength/2, 0);
            ctx.lineTo(baseLength/2, 0);
            ctx.stroke();

            // Draw step pattern at attachment points
            if (stepPoints.length >= 2) {
                attachmentPoints.forEach(point => {
                    const index = parseInt(point.split('-')[1]);
                    if (index < stepPoints.length) {
                        ctx.save();
                        const scale = size / baseLength;
                        ctx.translate(stepPoints[index].x * scale, stepPoints[index].y * scale);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        for (let i = 1; i < stepPoints.length; i++) {
                            ctx.lineTo(stepPoints[i].x * scale, stepPoints[i].y * scale);
                        }
                        ctx.stroke();
                        ctx.restore();
                    }
                });
            }
            
            ctx.restore();
        }

        function drawFractalRecursive(x, y, size, angle, iterations) {
            if (iterations === 0) return;
            
            const baseLength = parseInt(document.getElementById("baseLength").value);
            const scale = parseFloat(document.getElementById("scale").value);
            const rotation = parseFloat(document.getElementById("rotation").value) + frame;
            
            drawFractalStep(x, y, size, angle, baseLength);
            
            if (stepPoints.length >= 2) {
                attachmentPoints.forEach(point => {
                    const index = parseInt(point.split('-')[1]);
                    if (index < stepPoints.length) {
                        const newX = x + (stepPoints[index].x * size / baseLength);
                        const newY = y + (stepPoints[index].y * size / baseLength);
                        drawFractalRecursive(newX, newY, size * scale, angle + rotation, iterations - 1);
                    }
                });
            }
        }

        function animateFractal(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            const deltaTime = timestamp - lastTimestamp;
            const speed = parseFloat(document.getElementById("animationSpeed").value);
            
            frame += (deltaTime / 16.67) * speed;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = invertColors ? "white" : "black";
            
            drawFractalRecursive(canvas.width / 2, canvas.height / 2, 
                parseInt(document.getElementById("baseLength").value),
                0, parseInt(document.getElementById("iterations").value));
            
            lastTimestamp = timestamp;
            animationFrame = requestAnimationFrame(animateFractal);
        }

        function startAnimation() {
            if (!animationFrame) {
                lastTimestamp = 0;
                animateFractal(0);
            }
        }

        function stopAnimation() {
            cancelAnimationFrame(animationFrame);
            animationFrame = null;
        }

        function toggleInvertColors() {
            invertColors = !invertColors;
            document.body.style.backgroundColor = invertColors ? "black" : "white";
            document.body.style.color = invertColors ? "white" : "black";
            canvas.style.backgroundColor = invertColors ? "black" : "white";
            editorCanvas.style.backgroundColor = invertColors ? "black" : "white";
            drawEditor();
            resetFractal();
        }

        function resetFractal() {
            Object.keys(defaultValues).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.value = defaultValues[key];
                }
            });
            
            frame = 0;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = invertColors ? "white" : "black";
            drawFractalRecursive(canvas.width / 2, canvas.height / 2,
                parseInt(document.getElementById("baseLength").value),
                0, parseInt(document.getElementById("iterations").value));
        }

        // Initialize everything
        initializeEditor();
        resetFractal();
    </script>
</body>
</html>
